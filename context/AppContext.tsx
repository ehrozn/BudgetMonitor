import createContextHook from "@nkzw/create-context-hook";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useCallback, useEffect, useMemo, useState } from "react";
import {
    Account,
    Category,
    Transaction,
    UserSettings,
    TransactionType,
    BackupMetadata,
    RecurringTransaction,
    TransferRule,
    IncomeDistributionRule,
    IncomeDistributionCompletion,
} from "../types";
import {
    DEFAULT_INCOME_CATEGORIES,
    DEFAULT_EXPENSE_CATEGORIES,
    ACCOUNT_COLORS,
} from "../constants/categories";

const STORAGE_KEY = "@budget_app_data";
const TRANSFER_INCOME_NAME = "Transfer In";
const TRANSFER_EXPENSE_NAME = "Transfer Out";
const TRANSFER_INCOME_ICON = "ArrowDownToLine";
const TRANSFER_EXPENSE_ICON = "ArrowUpFromLine";

type TransferBuilderResult =
    | {
        success: true;
        accounts: Account[];
        transactions: Transaction[];
        transferGroupId: string;
    }
    | {
        success: false;
        error: string;
    };

interface TransferBuilderInput {
    accounts: Account[];
    transactions: Transaction[];
    fromAccountId: string;
    toAccountId: string;
    amount: number;
    date: string;
    incomeCategoryId: string;
    expenseCategoryId: string;
    note?: string | null;
    linkedRuleId?: string | null;
    autoGenerated?: boolean;
    parentTransactionId?: string | null;
}

interface AutoTransferPayload {
    baseTransaction: Transaction;
    accountsDraft: Account[];
    transactionsDraft: Transaction[];
}

interface AppData {
    settings: UserSettings;
    accounts: Account[];
    categories: Category[];
    transactions: Transaction[];
    recurringTransactions: RecurringTransaction[];
    transferRules: TransferRule[];
    backupMetadata: BackupMetadata;
    incomeDistributionRules: IncomeDistributionRule[];
    incomeDistributionCompletions: IncomeDistributionCompletion[];
}

const DEFAULT_SETTINGS: UserSettings = {
    id: "default",
    language: "en",
    currency: "USD",
    country: "US",
    backupProvider: "none",
    autoBackupEnabled: false,
    autoBackupFrequency: "weekly",
    lastSelectedAccountId: null,
    lastSelectedPeriodType: "day",
    lastCustomPeriodFrom: null,
    lastCustomPeriodTo: null,
    isFirstLaunch: true,
};

const DEFAULT_BACKUP_METADATA: BackupMetadata = {
    id: "backup-metadata",
    lastBackupAt: null,
    backupVersion: "1.0.0",
};

function generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).slice(2, 11)}`;
}

function roundCurrency(value: number): number {
    return Math.round(value * 100) / 100;
}

function clamp(value: number, minValue: number, maxValue: number): number {
    return Math.min(Math.max(value, minValue), maxValue);
}

function createInitialCategories(): Category[] {
    return [
        ...DEFAULT_INCOME_CATEGORIES.map((category) => ({
            ...category,
            id: generateId(),
        })),
        ...DEFAULT_EXPENSE_CATEGORIES.map((category) => ({
            ...category,
            id: generateId(),
        })),
    ];
}

function computeNextOccurrence(previous: Date, recurring: RecurringTransaction, baseStart: Date): Date {
    const next = new Date(previous);

    switch (recurring.repeatInterval) {
        case "daily":
            next.setDate(next.getDate() + 1);
            break;
        case "weekly":
            next.setDate(next.getDate() + 7);
            break;
        case "monthly": {
            const targetDay = recurring.repeatDay ?? baseStart.getDate();
            next.setMonth(next.getMonth() + 1);
            const monthLength = new Date(next.getFullYear(), next.getMonth() + 1, 0).getDate();
            next.setDate(Math.min(targetDay, monthLength));
            break;
        }
        case "yearly":
            next.setFullYear(next.getFullYear() + 1);
            break;
        default:
            next.setDate(next.getDate() + 1);
    }

    return next;
}

function sanitizeTransferRule(raw: Partial<TransferRule>): TransferRule {
    const now = new Date().toISOString();
    const allocationType: TransferRule["allocationType"] = raw.allocationType === "fixed" ? "fixed" : "percentage";
    const normalizedPercentage =
        allocationType === "percentage" ? clamp(raw.percentage ?? 0, 0, 100) : null;
    const normalizedFixedAmount = allocationType === "fixed" ? roundCurrency(raw.fixedAmount ?? 0) : null;

    return {
        id: raw.id ?? generateId(),
        sourceAccountId: raw.sourceAccountId ?? "",
        targetAccountId: raw.targetAccountId ?? "",
        allocationType,
        percentage: allocationType === "percentage" ? normalizedPercentage : null,
        fixedAmount: allocationType === "fixed" ? normalizedFixedAmount : null,
        noteTemplate: raw.noteTemplate ? raw.noteTemplate.trim() : null,
        isActive: raw.isActive ?? true,
        createdAt: raw.createdAt ?? now,
        updatedAt: raw.updatedAt ?? now,
    };
}

function formatTransferNote(
    template: string | null,
    fallback: string,
    amount: number,
    sourceName: string,
    targetName: string,
): string {
    if (!template) {
        return fallback;
    }

    const amountText = amount.toFixed(2);
    return template
        .replace(/{amount}/gi, amountText)
        .replace(/{from}/gi, sourceName)
        .replace(/{to}/gi, targetName);
}

function buildTransferPair(input: TransferBuilderInput): TransferBuilderResult {
    const {
        accounts,
        transactions,
        fromAccountId,
        toAccountId,
        amount,
        date,
        incomeCategoryId,
        expenseCategoryId,
        note,
        linkedRuleId,
        autoGenerated,
        parentTransactionId,
    } = input;

    const sourceAccount = accounts.find((account) => account.id === fromAccountId);
    const targetAccount = accounts.find((account) => account.id === toAccountId);

    if (!sourceAccount || !targetAccount) {
        return { success: false, error: "Account not found" };
    }

    if (sourceAccount.isArchived || targetAccount.isArchived) {
        return { success: false, error: "Cannot transfer using archived accounts" };
    }

    if (sourceAccount.id === targetAccount.id) {
        return { success: false, error: "Select two different accounts" };
    }

    const roundedAmount = roundCurrency(amount);

    if (roundedAmount <= 0) {
        return { success: false, error: "Transfer amount must be positive" };
    }

    if (sourceAccount.currentBalance < roundedAmount) {
        return { success: false, error: "Insufficient funds" };
    }

    const transferGroupId = generateId();
    const timestamp = new Date().toISOString();

    const outgoingTransaction: Transaction = {
        id: generateId(),
        accountId: sourceAccount.id,
        type: "expense",
        amount: roundedAmount,
        categoryId: expenseCategoryId,
        customCategoryName: null,
        transactionName: null,
        note: note ?? `Transfer to ${targetAccount.name}`,
        date,
        createdAt: timestamp,
        updatedAt: timestamp,
        isAutoGenerated: autoGenerated ?? false,
        recurringId: null,
        isTransfer: true,
        transferGroupId,
        linkedRuleId: linkedRuleId ?? null,
        parentTransactionId: parentTransactionId ?? null,
    };

    const incomingTransaction: Transaction = {
        id: generateId(),
        accountId: targetAccount.id,
        type: "income",
        amount: roundedAmount,
        categoryId: incomeCategoryId,
        customCategoryName: null,
        transactionName: null,
        note: note ?? `Transfer from ${sourceAccount.name}`,
        date,
        createdAt: timestamp,
        updatedAt: timestamp,
        isAutoGenerated: autoGenerated ?? false,
        recurringId: null,
        isTransfer: true,
        transferGroupId,
        linkedRuleId: linkedRuleId ?? null,
        parentTransactionId: parentTransactionId ?? null,
    };

    const updatedAccounts = accounts.map((account) => {
        if (account.id === sourceAccount.id) {
            return {
                ...account,
                currentBalance: roundCurrency(account.currentBalance - roundedAmount),
                updatedAt: timestamp,
            };
        }

        if (account.id === targetAccount.id) {
            return {
                ...account,
                currentBalance: roundCurrency(account.currentBalance + roundedAmount),
                updatedAt: timestamp,
            };
        }

        return account;
    });

    const updatedTransactions = [...transactions, outgoingTransaction, incomingTransaction];

    return {
        success: true,
        accounts: updatedAccounts,
        transactions: updatedTransactions,
        transferGroupId,
    };
}

export const [AppProvider, useApp] = createContextHook(() => {
    const [isLoading, setIsLoading] = useState<boolean>(true);
    const [settings, setSettings] = useState<UserSettings>(DEFAULT_SETTINGS);
    const [accounts, setAccounts] = useState<Account[]>([]);
    const [categories, setCategories] = useState<Category[]>([]);
    const [transactions, setTransactions] = useState<Transaction[]>([]);
    const [recurringTransactions, setRecurringTransactions] = useState<RecurringTransaction[]>([]);
    const [transferRules, setTransferRules] = useState<TransferRule[]>([]);
    const [backupMetadata, setBackupMetadata] = useState<BackupMetadata>(DEFAULT_BACKUP_METADATA);
    const [incomeDistributionRules, setIncomeDistributionRules] = useState<IncomeDistributionRule[]>([]);
    const [incomeDistributionCompletions, setIncomeDistributionCompletions] = useState<IncomeDistributionCompletion[]>([]);

    const saveData = useCallback(
        async (data: Partial<AppData>) => {
            try {
                const stored = await AsyncStorage.getItem(STORAGE_KEY);
                const persisted: Partial<AppData> = stored ? JSON.parse(stored) : {};
                const snapshot: AppData = {
                    settings: data.settings ?? persisted.settings ?? settings,
                    accounts: data.accounts ?? persisted.accounts ?? accounts,
                    categories: data.categories ?? persisted.categories ?? categories,
                    transactions: data.transactions ?? persisted.transactions ?? transactions,
                    recurringTransactions:
                        data.recurringTransactions ?? persisted.recurringTransactions ?? recurringTransactions,
                    transferRules: data.transferRules ?? persisted.transferRules ?? transferRules,
                    backupMetadata: data.backupMetadata ?? persisted.backupMetadata ?? backupMetadata,
                    incomeDistributionRules: data.incomeDistributionRules ?? persisted.incomeDistributionRules ?? incomeDistributionRules,
                    incomeDistributionCompletions: data.incomeDistributionCompletions ?? persisted.incomeDistributionCompletions ?? incomeDistributionCompletions,
                };
                await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(snapshot));
            } catch (error) {
                console.error("Error saving data:", error);
            }
        },
        [settings, accounts, categories, transactions, recurringTransactions, transferRules, backupMetadata, incomeDistributionRules, incomeDistributionCompletions],
    );

    useEffect(() => {
        const loadData = async () => {
            try {
                const stored = await AsyncStorage.getItem(STORAGE_KEY);

                if (stored) {
                    const parsed: Partial<AppData> = JSON.parse(stored);

                    const sanitizedSettings: UserSettings = {
                        ...DEFAULT_SETTINGS,
                        ...(parsed.settings ?? {}),
                        isFirstLaunch: parsed.settings?.isFirstLaunch ?? false,
                    };

                    const sanitizedAccounts: Account[] = (parsed.accounts ?? []).map((rawAccount) => {
                        const { isTaxVault: _legacyTaxFlag, ...rest } = rawAccount as Account & { isTaxVault?: boolean };
                        return {
                            ...rest,
                            initialBalance: roundCurrency(rawAccount.initialBalance),
                            currentBalance: roundCurrency(rawAccount.currentBalance),
                            color: rawAccount.color ?? ACCOUNT_COLORS[0],
                            icon: rawAccount.icon ?? "Wallet",
                            updatedAt: rawAccount.updatedAt ?? new Date().toISOString(),
                        };
                    });

                    const existingCategories = parsed.categories ?? [];
                    const mergedCategories: Category[] = existingCategories
                        .map((category) => ({
                            ...category,
                            name: category.name.trim(),
                            isUserDefined: category.isUserDefined ?? false,
                        }))
                        .filter((category) => Boolean(category.name));

                    const defaultCategories = createInitialCategories();
                    defaultCategories.forEach((category) => {
                        const hasCategory = mergedCategories.some(
                            (item) =>
                                item.type === category.type && item.name.toLowerCase() === category.name.toLowerCase(),
                        );
                        if (!hasCategory) {
                            mergedCategories.push({ ...category, id: generateId() });
                        }
                    });

                    const sanitizedTransactions: Transaction[] = (parsed.transactions ?? []).map((transaction) => ({
                        ...transaction,
                        amount: roundCurrency(transaction.amount),
                        note: transaction.note ? transaction.note.trim() : null,
                        customCategoryName: transaction.customCategoryName ? transaction.customCategoryName.trim() : null,
                        transactionName: transaction.transactionName ? transaction.transactionName.trim() : null,
                        isAutoGenerated: transaction.isAutoGenerated ?? false,
                        recurringId: transaction.recurringId ?? null,
                        isTransfer: transaction.isTransfer ?? false,
                        transferGroupId: transaction.transferGroupId ?? null,
                        linkedRuleId: transaction.linkedRuleId ?? null,
                        parentTransactionId: transaction.parentTransactionId ?? null,
                    }));

                    const sanitizedRecurring: RecurringTransaction[] = (parsed.recurringTransactions ?? []).map((recurring) => ({
                        ...recurring,
                        amount: roundCurrency(recurring.amount),
                        customCategoryName: recurring.customCategoryName ? recurring.customCategoryName.trim() : null,
                        note: recurring.note ? recurring.note.trim() : null,
                        isActive: recurring.isActive ?? true,
                        lastGeneratedAt: recurring.lastGeneratedAt ?? null,
                        processedOccurrences: recurring.processedOccurrences ?? 0,
                    }));

                    const sanitizedRules: TransferRule[] = (parsed.transferRules ?? [])
                        .map((rule) => sanitizeTransferRule(rule))
                        .filter((rule) => rule.sourceAccountId && rule.targetAccountId);

                    const sanitizedBackup: BackupMetadata = parsed.backupMetadata
                        ? {
                            ...DEFAULT_BACKUP_METADATA,
                            ...parsed.backupMetadata,
                        }
                        : DEFAULT_BACKUP_METADATA;

                    setSettings(sanitizedSettings);
                    setAccounts(sanitizedAccounts);
                    setCategories(mergedCategories);
                    setTransactions(sanitizedTransactions);
                    setRecurringTransactions(sanitizedRecurring);
                    setTransferRules(sanitizedRules);
                    setBackupMetadata(sanitizedBackup);
                    setIncomeDistributionRules(parsed.incomeDistributionRules ?? []);
                    setIncomeDistributionCompletions(parsed.incomeDistributionCompletions ?? []);

                    const sanitizedPayload: AppData = {
                        settings: sanitizedSettings,
                        accounts: sanitizedAccounts,
                        categories: mergedCategories,
                        transactions: sanitizedTransactions,
                        recurringTransactions: sanitizedRecurring,
                        transferRules: sanitizedRules,
                        backupMetadata: sanitizedBackup,
                        incomeDistributionRules: parsed.incomeDistributionRules ?? [],
                        incomeDistributionCompletions: parsed.incomeDistributionCompletions ?? [],
                    };

                    await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(sanitizedPayload));
                } else {
                    const initialCategories = createInitialCategories();
                    const initialPayload: AppData = {
                        settings: DEFAULT_SETTINGS,
                        accounts: [],
                        categories: initialCategories,
                        transactions: [],
                        recurringTransactions: [],
                        transferRules: [],
                        backupMetadata: DEFAULT_BACKUP_METADATA,
                        incomeDistributionRules: [],
                        incomeDistributionCompletions: [],
                    };

                    setSettings(DEFAULT_SETTINGS);
                    setAccounts([]);
                    setCategories(initialCategories);
                    setTransactions([]);
                    setRecurringTransactions([]);
                    setTransferRules([]);
                    setBackupMetadata(DEFAULT_BACKUP_METADATA);

                    await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(initialPayload));
                }
            } catch (error) {
                console.error("Error loading data:", error);
            } finally {
                setIsLoading(false);
            }
        };

        loadData();
    }, []);

    const updateSettings = useCallback(
        (updates: Partial<UserSettings>) => {
            const updated: UserSettings = { ...settings, ...updates };
            setSettings(updated);
            saveData({ settings: updated });
        },
        [settings, saveData],
    );

    const addAccount = useCallback(
        (name: string, type: "main" | "side" | "savings", initialBalance: number) => {
            if (!name.trim()) {
                console.error("Account name cannot be empty");
                return null;
            }

            if (initialBalance < 0) {
                console.error("Initial balance cannot be negative");
                return null;
            }

            const colorIndex = accounts.length % ACCOUNT_COLORS.length;
            const now = new Date().toISOString();
            const newAccount: Account = {
                id: generateId(),
                name: name.trim(),
                type,
                initialBalance: roundCurrency(initialBalance),
                currentBalance: roundCurrency(initialBalance),
                currency: settings.currency,
                color: ACCOUNT_COLORS[colorIndex],
                icon: "Wallet",
                isArchived: false,
                createdAt: now,
                updatedAt: now,
            };

            const updatedAccounts = [...accounts, newAccount];
            setAccounts(updatedAccounts);
            saveData({ accounts: updatedAccounts });

            if (accounts.length === 0) {
                updateSettings({
                    lastSelectedAccountId: newAccount.id,
                    isFirstLaunch: false,
                });
            }

            return newAccount;
        },
        [accounts, settings.currency, saveData, updateSettings],
    );

    const updateAccount = useCallback(
        (accountId: string, updates: Partial<Account>) => {
            const updatedAccounts = accounts.map((account) =>
                account.id === accountId
                    ? {
                        ...account,
                        ...updates,
                        initialBalance:
                            updates.initialBalance !== undefined
                                ? roundCurrency(updates.initialBalance)
                                : account.initialBalance,
                        currentBalance:
                            updates.currentBalance !== undefined
                                ? roundCurrency(updates.currentBalance)
                                : account.currentBalance,
                        updatedAt: new Date().toISOString(),
                    }
                    : account,
            );
            setAccounts(updatedAccounts);
            saveData({ accounts: updatedAccounts });
        },
        [accounts, saveData],
    );

    const deleteAccount = useCallback(
        (accountId: string) => {
            const account = accounts.find((item) => item.id === accountId);
            if (!account) {
                return { success: false, error: "Account not found." };
            }

            const updatedTransactions = transactions.filter((transaction) => transaction.accountId !== accountId);
            const updatedAccounts = accounts.filter((item) => item.id !== accountId);

            setAccounts(updatedAccounts);
            setTransactions(updatedTransactions);
            saveData({ accounts: updatedAccounts, transactions: updatedTransactions });

            if (updatedAccounts.length === 0) {
                updateSettings({ lastSelectedAccountId: null, isFirstLaunch: true });
            } else if (settings.lastSelectedAccountId === accountId) {
                const nextAccount = updatedAccounts.find((item) => !item.isArchived);
                if (nextAccount) {
                    updateSettings({ lastSelectedAccountId: nextAccount.id });
                } else {
                    updateSettings({ lastSelectedAccountId: null });
                }
            }

            return { success: true };
        },
        [accounts, transactions, settings.lastSelectedAccountId, saveData, updateSettings],
    );

    const ensureTransferCategory = useCallback(
        (type: TransactionType) => {
            const targetName = type === "income" ? TRANSFER_INCOME_NAME : TRANSFER_EXPENSE_NAME;
            const existing = categories.find(
                (category) => category.type === type && category.name.toLowerCase() === targetName.toLowerCase(),
            );

            if (existing) {
                return existing;
            }

            const newCategory: Category = {
                id: generateId(),
                type,
                name: targetName,
                icon: type === "income" ? TRANSFER_INCOME_ICON : TRANSFER_EXPENSE_ICON,
                isUserDefined: false,
            };

            const updatedCategories = [...categories, newCategory];
            setCategories(updatedCategories);
            saveData({ categories: updatedCategories });
            return newCategory;
        },
        [categories, saveData],
    );

    const applyAutoTransferRules = useCallback(
        ({ baseTransaction, accountsDraft, transactionsDraft }: AutoTransferPayload) => {
            if (transferRules.length === 0) {
                return { accounts: accountsDraft, transactions: transactionsDraft };
            }

            const relevantRules = transferRules.filter(
                (rule) => rule.isActive && rule.sourceAccountId === baseTransaction.accountId,
            );

            if (relevantRules.length === 0) {
                return { accounts: accountsDraft, transactions: transactionsDraft };
            }

            const expenseCategory = ensureTransferCategory("expense");
            const incomeCategory = ensureTransferCategory("income");

            let workingAccounts = accountsDraft;
            let workingTransactions = transactionsDraft;
            let remaining = baseTransaction.amount;

            relevantRules.forEach((rule) => {
                if (remaining <= 0) {
                    return;
                }

                if (rule.targetAccountId === rule.sourceAccountId) {
                    return;
                }

                const alreadyProcessed = workingTransactions.some(
                    (transaction) =>
                        transaction.parentTransactionId === baseTransaction.id &&
                        transaction.linkedRuleId === rule.id &&
                        transaction.isTransfer,
                );

                if (alreadyProcessed) {
                    console.log("[AutoTransfer] Skipping duplicate automation", {
                        baseTransactionId: baseTransaction.id,
                        ruleId: rule.id,
                    });
                    return;
                }

                const sourceAccount = workingAccounts.find((account) => account.id === rule.sourceAccountId);
                const targetAccount = workingAccounts.find((account) => account.id === rule.targetAccountId);

                if (!sourceAccount || !targetAccount) {
                    return;
                }

                const calculatedAmount =
                    rule.allocationType === "percentage"
                        ? roundCurrency(((rule.percentage ?? 0) / 100) * baseTransaction.amount)
                        : roundCurrency(rule.fixedAmount ?? 0);

                const amountToMove = calculatedAmount > remaining ? remaining : calculatedAmount;

                if (amountToMove <= 0) {
                    return;
                }

                const formattedNote = rule.noteTemplate
                    ? formatTransferNote(
                        rule.noteTemplate,
                        `Auto transfer to ${targetAccount.name}`,
                        amountToMove,
                        sourceAccount.name,
                        targetAccount.name,
                    )
                    : `Auto transfer to ${targetAccount.name}`;

                const result = buildTransferPair({
                    accounts: workingAccounts,
                    transactions: workingTransactions,
                    fromAccountId: rule.sourceAccountId,
                    toAccountId: rule.targetAccountId,
                    amount: amountToMove,
                    date: baseTransaction.date,
                    incomeCategoryId: incomeCategory.id,
                    expenseCategoryId: expenseCategory.id,
                    note: formattedNote,
                    linkedRuleId: rule.id,
                    autoGenerated: true,
                    parentTransactionId: baseTransaction.id,
                });

                if (!result.success) {
                    return;
                }

                workingAccounts = result.accounts;
                workingTransactions = result.transactions;
                remaining = roundCurrency(remaining - amountToMove);
            });

            return { accounts: workingAccounts, transactions: workingTransactions };
        },
        [transferRules, ensureTransferCategory],
    );

    const applyIncomeDistributionRules = useCallback(
        (incomeTransaction: Transaction, existingTransactions: Transaction[], existingAccounts: Account[]) => {
            const activeRules = incomeDistributionRules.filter(
                (rule) => rule.isActive && rule.accountId === incomeTransaction.accountId,
            );

            if (activeRules.length === 0) {
                return { transactions: existingTransactions, accounts: existingAccounts };
            }

            const timestamp = new Date().toISOString();
            const newCompletions: IncomeDistributionCompletion[] = [];

            activeRules.forEach((rule) => {
                const completion: IncomeDistributionCompletion = {
                    id: generateId(),
                    incomeTransactionId: incomeTransaction.id,
                    ruleId: rule.id,
                    distributionTransactionId: null,
                    status: "pending",
                    createdAt: timestamp,
                    updatedAt: timestamp,
                };

                newCompletions.push(completion);
            });

            const updatedCompletions = [...incomeDistributionCompletions, ...newCompletions];
            setIncomeDistributionCompletions(updatedCompletions);
            saveData({ incomeDistributionCompletions: updatedCompletions });

            return { transactions: existingTransactions, accounts: existingAccounts };
        },
        [incomeDistributionRules, incomeDistributionCompletions, saveData],
    );

    const addTransaction = useCallback(
        (
            accountId: string,
            type: TransactionType,
            amount: number,
            categoryId: string,
            date: string,
            note: string | null = null,
            customCategoryName: string | null = null,
            options?: {
                isAutoGenerated?: boolean;
                recurringId?: string | null;
                isTransfer?: boolean;
                transferGroupId?: string | null;
                linkedRuleId?: string | null;
                skipAutoAllocation?: boolean;
                parentTransactionId?: string | null;
                transactionName?: string | null;
            },
        ) => {
            const roundedAmount = roundCurrency(amount);

            if (roundedAmount <= 0) {
                console.error("Transaction amount must be positive");
                return null;
            }

            if (roundedAmount > 999999999) {
                console.error("Transaction amount is too large");
                return null;
            }

            const account = accounts.find((item) => item.id === accountId);
            if (!account) {
                console.error("Account not found");
                return null;
            }

            if (account.isArchived) {
                console.error("Cannot add transaction to archived account");
                return null;
            }

            const category = categories.find((item) => item.id === categoryId);
            if (!category) {
                console.error("Category not found");
                return null;
            }

            const timestamp = new Date().toISOString();
            const newTransaction: Transaction = {
                id: generateId(),
                accountId,
                type,
                amount: roundedAmount,
                categoryId,
                customCategoryName: customCategoryName ? customCategoryName.trim() : null,
                transactionName: options?.transactionName ? options.transactionName.trim() : null,
                note: note ? note.trim() : null,
                date,
                createdAt: timestamp,
                updatedAt: timestamp,
                isAutoGenerated: options?.isAutoGenerated ?? false,
                recurringId: options?.recurringId ?? null,
                isTransfer: options?.isTransfer ?? false,
                transferGroupId: options?.transferGroupId ?? null,
                linkedRuleId: options?.linkedRuleId ?? null,
                parentTransactionId: options?.parentTransactionId ?? null,
            };

            const updatedTransactions = [...transactions, newTransaction];

            const updatedAccounts = accounts.map((item) => {
                if (item.id !== accountId) {
                    return item;
                }

                const delta = type === "income" ? roundedAmount : -roundedAmount;
                return {
                    ...item,
                    currentBalance: roundCurrency(item.currentBalance + delta),
                    updatedAt: timestamp,
                };
            });

            let accountsDraft = updatedAccounts;
            let transactionsDraft = updatedTransactions;

            if (type === "income" && !newTransaction.isTransfer && !options?.skipAutoAllocation) {
                const autoResult = applyAutoTransferRules({
                    baseTransaction: newTransaction,
                    accountsDraft,
                    transactionsDraft,
                });
                accountsDraft = autoResult.accounts;
                transactionsDraft = autoResult.transactions;

                const distributionResult = applyIncomeDistributionRules(
                    newTransaction,
                    transactionsDraft,
                    accountsDraft
                );
                accountsDraft = distributionResult.accounts;
                transactionsDraft = distributionResult.transactions;

                setAccounts(accountsDraft);
                setTransactions(transactionsDraft);
                saveData({ accounts: accountsDraft, transactions: transactionsDraft });
            } else {
                setAccounts(accountsDraft);
                setTransactions(transactionsDraft);
                saveData({ accounts: accountsDraft, transactions: transactionsDraft });
            }

            return newTransaction;
        },
        [accounts, categories, transactions, applyAutoTransferRules, saveData, applyIncomeDistributionRules],
    );

    const updateTransaction = useCallback(
        (transactionId: string, updates: Partial<Transaction>) => {
            const transaction = transactions.find((item) => item.id === transactionId);
            if (!transaction) {
                console.error("Transaction not found");
                return;
            }

            if (transaction.isTransfer) {
                console.error("Transfer transactions cannot be edited");
                return;
            }

            if (updates.amount !== undefined) {
                const rounded = roundCurrency(updates.amount);
                if (rounded <= 0 || rounded > 999999999) {
                    console.error("Invalid amount");
                    return;
                }
            }

            const oldAccountId = transaction.accountId;
            const newAccountId = updates.accountId ?? transaction.accountId;
            const newAmount = updates.amount !== undefined ? roundCurrency(updates.amount) : transaction.amount;
            const newType = updates.type ?? transaction.type;
            const newDate = updates.date ?? transaction.date;

            let updatedAccounts = [...accounts];
            let updatedTransactions = [...transactions];

            const oldAccountIndex = updatedAccounts.findIndex((item) => item.id === oldAccountId);
            if (oldAccountIndex !== -1) {
                const oldAccount = updatedAccounts[oldAccountIndex];
                const revertedBalance =
                    transaction.type === "income"
                        ? oldAccount.currentBalance - transaction.amount
                        : oldAccount.currentBalance + transaction.amount;
                updatedAccounts[oldAccountIndex] = {
                    ...oldAccount,
                    currentBalance: roundCurrency(revertedBalance),
                    updatedAt: new Date().toISOString(),
                };
            }

            const newAccountIndex = updatedAccounts.findIndex((item) => item.id === newAccountId);
            if (newAccountIndex !== -1) {
                const newAccount = updatedAccounts[newAccountIndex];
                const recalculatedBalance =
                    newType === "income"
                        ? newAccount.currentBalance + newAmount
                        : newAccount.currentBalance - newAmount;
                updatedAccounts[newAccountIndex] = {
                    ...newAccount,
                    currentBalance: roundCurrency(recalculatedBalance),
                    updatedAt: new Date().toISOString(),
                };
            }

            const updatedTransaction: Transaction = {
                ...transaction,
                ...updates,
                amount: newAmount,
                type: newType,
                accountId: newAccountId,
                date: newDate,
                note:
                    updates.note !== undefined
                        ? updates.note
                            ? updates.note.trim()
                            : null
                        : transaction.note,
                customCategoryName:
                    updates.customCategoryName !== undefined
                        ? updates.customCategoryName
                            ? updates.customCategoryName.trim()
                            : null
                        : transaction.customCategoryName,
                updatedAt: new Date().toISOString(),
                recurringId: updates.recurringId ?? transaction.recurringId,
            };

            updatedTransactions = updatedTransactions.map((item) =>
                item.id === transactionId ? updatedTransaction : item,
            );

            const autoGeneratedChildren = updatedTransactions.filter(
                (item) => item.parentTransactionId === transactionId && item.isAutoGenerated && item.isTransfer
            );

            if (autoGeneratedChildren.length > 0) {
                console.log("[UpdateTransaction] Found", autoGeneratedChildren.length, "auto-generated children");

                const amountChanged = transaction.amount !== newAmount;
                const dateChanged = transaction.date !== newDate;

                if (amountChanged || dateChanged) {
                    autoGeneratedChildren.forEach((child) => {
                        updatedTransactions = updatedTransactions.filter((item) => item.transferGroupId !== child.transferGroupId);

                        const rule = transferRules.find((r) => r.id === child.linkedRuleId);
                        if (!rule) {
                            console.log("[UpdateTransaction] Rule not found for child", child.id);
                            return;
                        }

                        const sibling = transactions.find(
                            (item) => item.transferGroupId === child.transferGroupId && item.id !== child.id
                        );

                        if (sibling) {
                            updatedAccounts = updatedAccounts.map((account) => {
                                if (account.id === child.accountId) {
                                    const delta = child.type === "income" ? -child.amount : child.amount;
                                    return {
                                        ...account,
                                        currentBalance: roundCurrency(account.currentBalance + delta),
                                        updatedAt: new Date().toISOString(),
                                    };
                                }
                                if (account.id === sibling.accountId) {
                                    const delta = sibling.type === "income" ? -sibling.amount : sibling.amount;
                                    return {
                                        ...account,
                                        currentBalance: roundCurrency(account.currentBalance + delta),
                                        updatedAt: new Date().toISOString(),
                                    };
                                }
                                return account;
                            });
                        }
                    });

                    const expenseCategory = ensureTransferCategory("expense");
                    const incomeCategory = ensureTransferCategory("income");

                    const activeRules = transferRules.filter(
                        (rule) => rule.isActive && rule.sourceAccountId === newAccountId
                    );

                    activeRules.forEach((rule) => {
                        const sourceAccount = updatedAccounts.find((account) => account.id === rule.sourceAccountId);
                        const targetAccount = updatedAccounts.find((account) => account.id === rule.targetAccountId);

                        if (!sourceAccount || !targetAccount) {
                            return;
                        }

                        const calculatedAmount =
                            rule.allocationType === "percentage"
                                ? roundCurrency(((rule.percentage ?? 0) / 100) * newAmount)
                                : roundCurrency(rule.fixedAmount ?? 0);

                        if (calculatedAmount <= 0) {
                            return;
                        }

                        const formattedNote = rule.noteTemplate
                            ? formatTransferNote(
                                rule.noteTemplate,
                                `Auto transfer to ${targetAccount.name}`,
                                calculatedAmount,
                                sourceAccount.name,
                                targetAccount.name,
                            )
                            : `Auto transfer to ${targetAccount.name}`;

                        const result = buildTransferPair({
                            accounts: updatedAccounts,
                            transactions: updatedTransactions,
                            fromAccountId: rule.sourceAccountId,
                            toAccountId: rule.targetAccountId,
                            amount: calculatedAmount,
                            date: newDate,
                            incomeCategoryId: incomeCategory.id,
                            expenseCategoryId: expenseCategory.id,
                            note: formattedNote,
                            linkedRuleId: rule.id,
                            autoGenerated: true,
                            parentTransactionId: transactionId,
                        });

                        if (result.success) {
                            updatedAccounts = result.accounts;
                            updatedTransactions = result.transactions;
                        }
                    });
                }
            }

            setAccounts(updatedAccounts);
            setTransactions(updatedTransactions);
            saveData({ accounts: updatedAccounts, transactions: updatedTransactions });
        },
        [transactions, accounts, transferRules, ensureTransferCategory, saveData],
    );

    const deleteTransaction = useCallback(
        (transactionId: string) => {
            const transaction = transactions.find((item) => item.id === transactionId);
            if (!transaction) {
                return;
            }

            let idsToDelete: string[] = [];

            if (transaction.isTransfer && transaction.transferGroupId) {
                idsToDelete = transactions
                    .filter((item) => item.transferGroupId === transaction.transferGroupId)
                    .map((item) => item.id);
            } else {
                idsToDelete = [transactionId];

                const autoGeneratedChildren = transactions.filter(
                    (item) => item.parentTransactionId === transactionId && item.isAutoGenerated && item.isTransfer
                );

                if (autoGeneratedChildren.length > 0) {
                    console.log("[DeleteTransaction] Found", autoGeneratedChildren.length, "auto-generated children to delete");
                    autoGeneratedChildren.forEach((child) => {
                        const groupTransactions = transactions.filter(
                            (item) => item.transferGroupId === child.transferGroupId
                        );
                        groupTransactions.forEach((groupTx) => {
                            if (!idsToDelete.includes(groupTx.id)) {
                                idsToDelete.push(groupTx.id);
                            }
                        });
                    });
                }
            }

            let accountsDraft = accounts;
            let transactionsDraft = transactions;

            idsToDelete.forEach((id) => {
                const target = transactionsDraft.find((item) => item.id === id);
                if (!target) {
                    return;
                }

                accountsDraft = accountsDraft.map((account) => {
                    if (account.id !== target.accountId) {
                        return account;
                    }

                    const balanceDelta = target.type === "income" ? -target.amount : target.amount;
                    return {
                        ...account,
                        currentBalance: roundCurrency(account.currentBalance + balanceDelta),
                        updatedAt: new Date().toISOString(),
                    };
                });

                transactionsDraft = transactionsDraft.filter((item) => item.id !== id);
            });

            setAccounts(accountsDraft);
            setTransactions(transactionsDraft);
            saveData({ accounts: accountsDraft, transactions: transactionsDraft });
        },
        [transactions, accounts, saveData],
    );

    const addCategory = useCallback(
        (type: TransactionType, name: string, icon: string) => {
            const trimmedName = name.trim();
            if (!trimmedName) {
                console.error("addCategory error: name is required");
                return null;
            }

            if (!icon) {
                console.error("addCategory error: icon is required");
                return null;
            }

            const existing = categories.find(
                (category) =>
                    category.type === type && category.name.toLowerCase() === trimmedName.toLowerCase(),
            );

            if (existing) {
                return existing;
            }

            const newCategory: Category = {
                id: generateId(),
                type,
                name: trimmedName,
                icon,
                isUserDefined: true,
            };

            const updatedCategories = [...categories, newCategory];
            setCategories(updatedCategories);
            saveData({ categories: updatedCategories });
            return newCategory;
        },
        [categories, saveData],
    );

    const deleteCategory = useCallback(
        (categoryId: string) => {
            const category = categories.find((item) => item.id === categoryId);
            if (!category || !category.isUserDefined) {
                return { success: false, error: "Cannot delete default category" };
            }

            const categoryTransactions = transactions.filter((transaction) => transaction.categoryId === categoryId);
            if (categoryTransactions.length > 0) {
                return {
                    success: false,
                    error: "This category is used in transactions. Delete transactions first.",
                };
            }

            const categoryRecurring = recurringTransactions.filter((recurring) => recurring.categoryId === categoryId);
            if (categoryRecurring.length > 0) {
                return {
                    success: false,
                    error: "This category is used in recurring planners. Update them first.",
                };
            }

            const updatedCategories = categories.filter((item) => item.id !== categoryId);
            setCategories(updatedCategories);
            saveData({ categories: updatedCategories });
            return { success: true };
        },
        [categories, transactions, recurringTransactions, saveData],
    );

    const addRecurringTransaction = useCallback(
        (
            input: Omit<RecurringTransaction, "id" | "lastGeneratedAt" | "processedOccurrences">,
            options?: { initialOccurrenceCaptured?: boolean },
        ) => {
            if (input.amount <= 0) {
                console.error("Recurring amount must be positive");
                return null;
            }

            const account = accounts.find((item) => item.id === input.accountId && !item.isArchived);
            if (!account) {
                console.error("Account not found or archived");
                return null;
            }

            const category = categories.find((item) => item.id === input.categoryId);
            if (!category) {
                console.error("Category not found");
                return null;
            }

            const startDate = new Date(input.startDate);
            if (Number.isNaN(startDate.getTime())) {
                console.error("Invalid start date");
                return null;
            }

            const hasInitialOccurrence = Boolean(options?.initialOccurrenceCaptured);

            const recurring: RecurringTransaction = {
                ...input,
                id: generateId(),
                amount: roundCurrency(input.amount),
                customCategoryName: input.customCategoryName ? input.customCategoryName.trim() : null,
                note: input.note ? input.note.trim() : null,
                isActive: input.isActive,
                lastGeneratedAt: hasInitialOccurrence ? input.startDate : null,
                processedOccurrences: hasInitialOccurrence ? 1 : 0,
            };

            const updatedRecurring = [...recurringTransactions, recurring];
            setRecurringTransactions(updatedRecurring);
            saveData({ recurringTransactions: updatedRecurring });
            return recurring;
        },
        [accounts, categories, recurringTransactions, saveData],
    );

    const updateRecurringTransaction = useCallback(
        (recurringId: string, updates: Partial<RecurringTransaction>) => {
            const updatedRecurring = recurringTransactions.map((item) =>
                item.id === recurringId
                    ? {
                        ...item,
                        ...updates,
                        amount:
                            updates.amount !== undefined ? roundCurrency(updates.amount) : item.amount,
                        customCategoryName:
                            updates.customCategoryName !== undefined
                                ? updates.customCategoryName
                                    ? updates.customCategoryName.trim()
                                    : null
                                : item.customCategoryName,
                        note:
                            updates.note !== undefined
                                ? updates.note
                                    ? updates.note.trim()
                                    : null
                                : item.note,
                    }
                    : item,
            );
            setRecurringTransactions(updatedRecurring);
            saveData({ recurringTransactions: updatedRecurring });
        },
        [recurringTransactions, saveData],
    );

    const deleteRecurringTransaction = useCallback(
        (recurringId: string) => {
            const updatedRecurring = recurringTransactions.filter((item) => item.id !== recurringId);
            setRecurringTransactions(updatedRecurring);
            saveData({ recurringTransactions: updatedRecurring });
        },
        [recurringTransactions, saveData],
    );

    const toggleRecurringTransaction = useCallback(
        (recurringId: string, isActive: boolean) => {
            updateRecurringTransaction(recurringId, { isActive });
        },
        [updateRecurringTransaction],
    );

    const processRecurringTransactions = useCallback(() => {
        if (isLoading) {
            return;
        }

        const now = new Date();
        const updatedRecurring: RecurringTransaction[] = [];
        let hasUpdates = false;

        recurringTransactions.forEach((recurring) => {
            if (!recurring.isActive) {
                updatedRecurring.push(recurring);
                return;
            }

            const startDate = new Date(recurring.startDate);
            if (Number.isNaN(startDate.getTime())) {
                updatedRecurring.push(recurring);
                return;
            }

            const endDate = recurring.endDate ? new Date(recurring.endDate) : null;
            const cloned = { ...recurring };
            let processed = cloned.processedOccurrences;
            let lastGenerated = cloned.lastGeneratedAt ? new Date(cloned.lastGeneratedAt) : null;
            let nextDate: Date;

            if (processed === 0) {
                nextDate = startDate;
            } else if (lastGenerated) {
                nextDate = computeNextOccurrence(lastGenerated, cloned, startDate);
            } else {
                nextDate = startDate;
            }

            const maxOccurrences = cloned.endType === "occurrences" ? cloned.occurrences ?? 0 : null;

            while (true) {
                if (Number.isNaN(nextDate.getTime())) {
                    break;
                }

                if (nextDate > now) {
                    break;
                }

                if (cloned.endType === "endDate" && endDate) {
                    const endBoundary = new Date(endDate);
                    endBoundary.setHours(23, 59, 59, 999);
                    if (nextDate > endBoundary) {
                        break;
                    }
                }

                if (maxOccurrences !== null && processed >= maxOccurrences) {
                    break;
                }

                const created = addTransaction(
                    cloned.accountId,
                    cloned.type,
                    cloned.amount,
                    cloned.categoryId,
                    new Date(nextDate).toISOString(),
                    cloned.note,
                    cloned.customCategoryName,
                    {
                        isAutoGenerated: true,
                        recurringId: cloned.id,
                    },
                );

                if (!created) {
                    break;
                }

                processed += 1;
                lastGenerated = new Date(nextDate);
                cloned.lastGeneratedAt = lastGenerated.toISOString();
                cloned.processedOccurrences = processed;
                hasUpdates = true;

                nextDate = computeNextOccurrence(new Date(nextDate), cloned, startDate);
            }

            updatedRecurring.push(cloned);
        });

        if (hasUpdates) {
            setRecurringTransactions(updatedRecurring);
            saveData({ recurringTransactions: updatedRecurring });
        }
    }, [recurringTransactions, isLoading, addTransaction, saveData]);

    useEffect(() => {
        if (!isLoading) {
            processRecurringTransactions();
        }
    }, [isLoading, processRecurringTransactions]);

    const getActiveAccounts = useCallback(() => {
        return accounts.filter((account) => !account.isArchived);
    }, [accounts]);

    const getCategoriesByType = useCallback(
        (type: TransactionType) => {
            return categories.filter((category) => category.type === type);
        },
        [categories],
    );

    const getTransactionsByAccountAndPeriod = useCallback(
        (accountId: string, from: Date, to: Date) => {
            return transactions
                .filter((transaction) => {
                    const transactionDate = new Date(transaction.date);
                    return transaction.accountId === accountId && transactionDate >= from && transactionDate <= to;
                })
                .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
        },
        [transactions],
    );

    const getPeriodStats = useCallback(
        (accountId: string, from: Date, to: Date) => {
            const periodTransactions = getTransactionsByAccountAndPeriod(accountId, from, to);

            const income = periodTransactions
                .filter((transaction) => transaction.type === "income")
                .reduce((sum, transaction) => sum + transaction.amount, 0);

            const expenses = periodTransactions
                .filter((transaction) => transaction.type === "expense")
                .reduce((sum, transaction) => sum + transaction.amount, 0);

            const expensesByCategory = periodTransactions
                .filter((transaction) => transaction.type === "expense")
                .reduce((accumulator, transaction) => {
                    const category = categories.find((item) => item.id === transaction.categoryId);
                    const categoryName = transaction.customCategoryName || category?.name || "Other";
                    const currentValue = accumulator[categoryName] ?? 0;
                    return {
                        ...accumulator,
                        [categoryName]: currentValue + transaction.amount,
                    };
                }, {} as Record<string, number>);

            return {
                income,
                expenses,
                balance: income - expenses,
                expensesByCategory,
            };
        },
        [getTransactionsByAccountAndPeriod, categories],
    );

    const getTotalBalance = useCallback(() => {
        return accounts
            .filter((account) => !account.isArchived)
            .reduce((sum, account) => sum + account.currentBalance, 0);
    }, [accounts]);

    const exportData = useCallback(async () => {
        try {
            const timestamp = new Date().toISOString();
            const metadata: BackupMetadata = {
                id: backupMetadata.id,
                lastBackupAt: timestamp,
                backupVersion: "1.0.0",
            };

            const data = {
                settings,
                accounts,
                categories,
                transactions,
                recurringTransactions,
                transferRules,
                backupMetadata: metadata,
                exportDate: timestamp,
                version: "1.0.0",
            };

            setBackupMetadata(metadata);
            await saveData({ backupMetadata: metadata });
            return JSON.stringify(data, null, 2);
        } catch (error) {
            console.error("Error exporting data:", error);
            return null;
        }
    }, [settings, accounts, categories, transactions, recurringTransactions, transferRules, backupMetadata, saveData]);

    const importData = useCallback(
        async (payload: string): Promise<{ success: boolean; error?: string }> => {
            try {
                const parsed = JSON.parse(payload) as Partial<AppData> & { version?: string };

                if (!parsed.settings || !parsed.accounts || !parsed.categories || !parsed.transactions) {
                    return { success: false, error: "Backup file is missing required data." };
                }

                const sanitizedSettings: UserSettings = {
                    ...DEFAULT_SETTINGS,
                    ...parsed.settings,
                    isFirstLaunch: false,
                };

                const sanitizedAccounts = (parsed.accounts as Account[]).map((rawAccount) => {
                    const { isTaxVault: _legacyTaxFlag, ...rest } = rawAccount as Account & { isTaxVault?: boolean };
                    return {
                        ...rest,
                        currentBalance: roundCurrency(rawAccount.currentBalance),
                        initialBalance: roundCurrency(rawAccount.initialBalance),
                        updatedAt: new Date().toISOString(),
                    };
                });

                const sanitizedCategories = (parsed.categories as Category[]).map((category) => ({
                    ...category,
                    id: category.id || generateId(),
                    name: category.name.trim(),
                    icon: category.icon || "Wallet",
                    isUserDefined: category.isUserDefined ?? false,
                }));

                const defaultCategories = createInitialCategories();
                defaultCategories.forEach((category) => {
                    const hasCategory = sanitizedCategories.some(
                        (item) => item.type === category.type && item.name.toLowerCase() === category.name.toLowerCase(),
                    );
                    if (!hasCategory) {
                        sanitizedCategories.push({ ...category, id: generateId() });
                    }
                });

                const sanitizedTransactions = (parsed.transactions as Transaction[]).map((transaction) => ({
                    ...transaction,
                    amount: roundCurrency(transaction.amount),
                    transactionName: transaction.transactionName ? transaction.transactionName.trim() : null,
                    createdAt: transaction.createdAt || new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    isAutoGenerated: transaction.isAutoGenerated ?? false,
                    recurringId: transaction.recurringId ?? null,
                    isTransfer: transaction.isTransfer ?? false,
                    transferGroupId: transaction.transferGroupId ?? null,
                    linkedRuleId: transaction.linkedRuleId ?? null,
                    parentTransactionId: transaction.parentTransactionId ?? null,
                }));

                const sanitizedRecurring = (parsed.recurringTransactions as RecurringTransaction[] | undefined)?.map(
                    (recurring) => ({
                        ...recurring,
                        amount: roundCurrency(recurring.amount),
                        customCategoryName: recurring.customCategoryName ? recurring.customCategoryName.trim() : null,
                        note: recurring.note ? recurring.note.trim() : null,
                        isActive: recurring.isActive ?? true,
                        lastGeneratedAt: recurring.lastGeneratedAt ?? null,
                        processedOccurrences: recurring.processedOccurrences ?? 0,
                    }),
                ) ?? [];

                const sanitizedRules = (parsed.transferRules as TransferRule[] | undefined)?.map((rule) =>
                    sanitizeTransferRule(rule),
                ) ?? [];

                const metadata: BackupMetadata = parsed.backupMetadata
                    ? {
                        ...DEFAULT_BACKUP_METADATA,
                        ...parsed.backupMetadata,
                        lastBackupAt: new Date().toISOString(),
                    }
                    : {
                        ...DEFAULT_BACKUP_METADATA,
                        lastBackupAt: new Date().toISOString(),
                        backupVersion: parsed.version || DEFAULT_BACKUP_METADATA.backupVersion,
                    };

                const persisted: AppData = {
                    settings: sanitizedSettings,
                    accounts: sanitizedAccounts,
                    categories: sanitizedCategories,
                    transactions: sanitizedTransactions,
                    recurringTransactions: sanitizedRecurring,
                    transferRules: sanitizedRules,
                    backupMetadata: metadata,
                    incomeDistributionRules: parsed.incomeDistributionRules ?? [],
                    incomeDistributionCompletions: parsed.incomeDistributionCompletions ?? [],
                };

                setSettings(sanitizedSettings);
                setAccounts(sanitizedAccounts);
                setCategories(sanitizedCategories);
                setTransactions(sanitizedTransactions);
                setRecurringTransactions(sanitizedRecurring);
                setTransferRules(sanitizedRules);
                setBackupMetadata(metadata);

                await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(persisted));
                processRecurringTransactions();
                return { success: true };
            } catch (error) {
                console.error("Error importing data:", error);
                return {
                    success: false,
                    error: "Unable to import backup. Please verify the file and try again.",
                };
            }
        },
        [processRecurringTransactions],
    );

    const transferBetweenAccounts = useCallback(
        (params: { fromAccountId: string; toAccountId: string; amount: number; date?: string; note?: string | null }) => {
            const { fromAccountId, toAccountId, amount, date, note } = params;
            const incomeCategory = ensureTransferCategory("income");
            const expenseCategory = ensureTransferCategory("expense");

            const result = buildTransferPair({
                accounts,
                transactions,
                fromAccountId,
                toAccountId,
                amount,
                date: date ?? new Date().toISOString(),
                incomeCategoryId: incomeCategory.id,
                expenseCategoryId: expenseCategory.id,
                note: note ? note.trim() : null,
            });

            if (!result.success) {
                return { success: false, error: result.error };
            }

            setAccounts(result.accounts);
            setTransactions(result.transactions);
            saveData({ accounts: result.accounts, transactions: result.transactions });
            return { success: true, transferGroupId: result.transferGroupId };
        },
        [accounts, transactions, ensureTransferCategory, saveData],
    );

    const addTransferRule = useCallback(
        (input: {
            sourceAccountId: string;
            targetAccountId: string;
            allocationType: "percentage" | "fixed";
            percentage?: number;
            fixedAmount?: number;
            noteTemplate?: string | null;
        }) => {
            if (input.sourceAccountId === input.targetAccountId) {
                return { success: false, error: "Choose two different accounts" };
            }

            const sourceExists = accounts.some((account) => account.id === input.sourceAccountId);
            const targetExists = accounts.some((account) => account.id === input.targetAccountId);

            if (!sourceExists || !targetExists) {
                return { success: false, error: "Account not found" };
            }

            const now = new Date().toISOString();
            const allocationType = input.allocationType;
            const percentageValue = allocationType === "percentage" ? clamp(input.percentage ?? 0, 0, 100) : null;
            const fixedValue = allocationType === "fixed" ? roundCurrency(input.fixedAmount ?? 0) : null;

            if (allocationType === "percentage" && (!percentageValue || percentageValue <= 0)) {
                return { success: false, error: "Percentage must be greater than 0" };
            }

            if (allocationType === "fixed" && (!fixedValue || fixedValue <= 0)) {
                return { success: false, error: "Amount must be greater than 0" };
            }

            const newRule: TransferRule = {
                id: generateId(),
                sourceAccountId: input.sourceAccountId,
                targetAccountId: input.targetAccountId,
                allocationType,
                percentage: allocationType === "percentage" ? percentageValue : null,
                fixedAmount: allocationType === "fixed" ? fixedValue : null,
                noteTemplate: input.noteTemplate ? input.noteTemplate.trim() : null,
                isActive: true,
                createdAt: now,
                updatedAt: now,
            };

            const updatedRules = [...transferRules, newRule];
            setTransferRules(updatedRules);
            saveData({ transferRules: updatedRules });
            return { success: true, rule: newRule };
        },
        [accounts, transferRules, saveData],
    );

    const updateTransferRule = useCallback(
        (
            ruleId: string,
            updates: Partial<Pick<TransferRule, "allocationType" | "percentage" | "fixedAmount" | "noteTemplate" | "isActive" | "sourceAccountId" | "targetAccountId">>,
        ) => {
            const exists = transferRules.some((rule) => rule.id === ruleId);
            if (!exists) {
                return { success: false, error: "Rule not found" };
            }

            const updatedRules = transferRules.map((rule) => {
                if (rule.id !== ruleId) {
                    return rule;
                }

                const allocationType = updates.allocationType ?? rule.allocationType;
                const percentage =
                    allocationType === "percentage"
                        ? clamp(updates.percentage ?? rule.percentage ?? 0, 0, 100)
                        : null;
                const fixedAmount =
                    allocationType === "fixed"
                        ? roundCurrency(updates.fixedAmount ?? rule.fixedAmount ?? 0)
                        : null;

                return {
                    ...rule,
                    ...updates,
                    allocationType,
                    percentage,
                    fixedAmount,
                    noteTemplate:
                        updates.noteTemplate !== undefined
                            ? updates.noteTemplate
                                ? updates.noteTemplate.trim()
                                : null
                            : rule.noteTemplate,
                    updatedAt: new Date().toISOString(),
                };
            });

            setTransferRules(updatedRules);
            saveData({ transferRules: updatedRules });
            return { success: true };
        },
        [transferRules, saveData],
    );

    const deleteTransferRule = useCallback(
        (ruleId: string) => {
            const updatedRules = transferRules.filter((rule) => rule.id !== ruleId);
            if (updatedRules.length === transferRules.length) {
                return { success: false, error: "Rule not found" };
            }

            setTransferRules(updatedRules);
            saveData({ transferRules: updatedRules });
            return { success: true };
        },
        [transferRules, saveData],
    );

    const toggleTransferRule = useCallback(
        (ruleId: string, isActive: boolean) => {
            return updateTransferRule(ruleId, { isActive });
        },
        [updateTransferRule],
    );



    const addIncomeDistributionRule = useCallback(
        (input: {
            accountId: string;
            name: string;
            description: string | null;
            percentage: number;
            categoryId: string;
            color: string;
            icon: string;
            linkedToSmartTransfer?: boolean;
        }) => {
            if (!input.name.trim()) {
                return { success: false, error: "Name is required" };
            }

            if (input.percentage <= 0 || input.percentage > 100) {
                return { success: false, error: "Percentage must be between 1 and 100" };
            }

            const accountExists = accounts.some((account) => account.id === input.accountId);
            if (!accountExists) {
                return { success: false, error: "Account not found" };
            }

            const categoryExists = categories.some(
                (category) => category.id === input.categoryId && category.type === "expense",
            );
            if (!categoryExists) {
                return { success: false, error: "Category not found" };
            }

            const now = new Date().toISOString();
            const maxOrder = incomeDistributionRules.reduce((max, rule) => Math.max(max, rule.order), 0);

            const newRule: IncomeDistributionRule = {
                id: generateId(),
                accountId: input.accountId,
                name: input.name.trim(),
                description: input.description ? input.description.trim() : null,
                percentage: clamp(input.percentage, 0, 100),
                categoryId: input.categoryId,
                color: input.color,
                icon: input.icon,
                isActive: true,
                linkedToSmartTransfer: input.linkedToSmartTransfer ?? false,
                order: maxOrder + 1,
                createdAt: now,
                updatedAt: now,
            };

            const updatedRules = [...incomeDistributionRules, newRule];
            setIncomeDistributionRules(updatedRules);
            saveData({ incomeDistributionRules: updatedRules });
            return { success: true, rule: newRule };
        },
        [accounts, categories, incomeDistributionRules, saveData],
    );

    const updateIncomeDistributionRule = useCallback(
        (ruleId: string, updates: Partial<IncomeDistributionRule>) => {
            const exists = incomeDistributionRules.some((rule) => rule.id === ruleId);
            if (!exists) {
                return { success: false, error: "Rule not found" };
            }

            if (updates.percentage !== undefined && (updates.percentage <= 0 || updates.percentage > 100)) {
                return { success: false, error: "Percentage must be between 1 and 100" };
            }

            const updatedRules = incomeDistributionRules.map((rule) => {
                if (rule.id !== ruleId) {
                    return rule;
                }

                return {
                    ...rule,
                    ...updates,
                    name: updates.name !== undefined ? updates.name.trim() : rule.name,
                    description:
                        updates.description !== undefined
                            ? updates.description
                                ? updates.description.trim()
                                : null
                            : rule.description,
                    percentage:
                        updates.percentage !== undefined ? clamp(updates.percentage, 0, 100) : rule.percentage,
                    updatedAt: new Date().toISOString(),
                };
            });

            setIncomeDistributionRules(updatedRules);
            saveData({ incomeDistributionRules: updatedRules });
            return { success: true };
        },
        [incomeDistributionRules, saveData],
    );

    const deleteIncomeDistributionRule = useCallback(
        (ruleId: string) => {
            const updatedRules = incomeDistributionRules.filter((rule) => rule.id !== ruleId);
            if (updatedRules.length === incomeDistributionRules.length) {
                return { success: false, error: "Rule not found" };
            }

            const updatedSubAccountTransactions = incomeDistributionCompletions.filter(
                (transaction) => transaction.ruleId !== ruleId,
            );

            setIncomeDistributionRules(updatedRules);
            setIncomeDistributionCompletions(updatedSubAccountTransactions);
            saveData({ incomeDistributionRules: updatedRules, incomeDistributionCompletions: updatedSubAccountTransactions });
            return { success: true };
        },
        [incomeDistributionRules, incomeDistributionCompletions, saveData],
    );

    const toggleIncomeDistributionRule = useCallback(
        (ruleId: string, isActive: boolean) => {
            return updateIncomeDistributionRule(ruleId, { isActive });
        },
        [updateIncomeDistributionRule],
    );

    const saveIncomeDistributionCompletion = useCallback(
        (incomeTransactionId: string, ruleId: string, status: "completed" | "skipped", distributionTransactionId: string | null) => {
            const timestamp = new Date().toISOString();
            const existingCompletion = incomeDistributionCompletions.find(
                (c) => c.incomeTransactionId === incomeTransactionId && c.ruleId === ruleId
            );

            let updatedCompletions: IncomeDistributionCompletion[];

            if (existingCompletion) {
                updatedCompletions = incomeDistributionCompletions.map((c) =>
                    c.id === existingCompletion.id
                        ? {
                            ...c,
                            status,
                            distributionTransactionId,
                            updatedAt: timestamp,
                        }
                        : c
                );
            } else {
                const newCompletion: IncomeDistributionCompletion = {
                    id: generateId(),
                    incomeTransactionId,
                    ruleId,
                    distributionTransactionId,
                    status,
                    createdAt: timestamp,
                    updatedAt: timestamp,
                };
                updatedCompletions = [...incomeDistributionCompletions, newCompletion];
            }

            setIncomeDistributionCompletions(updatedCompletions);
            saveData({ incomeDistributionCompletions: updatedCompletions });
            return { success: true };
        },
        [incomeDistributionCompletions, saveData],
    );

    const value = useMemo(
        () => ({
            isLoading,
            settings,
            accounts,
            categories,
            transactions,
            recurringTransactions,
            transferRules,
            backupMetadata,
            incomeDistributionRules,
            incomeDistributionCompletions,
            updateSettings,
            addAccount,
            updateAccount,
            deleteAccount,
            addTransaction,
            updateTransaction,
            deleteTransaction,
            addCategory,
            deleteCategory,
            getActiveAccounts,
            getCategoriesByType,
            getTransactionsByAccountAndPeriod,
            getPeriodStats,
            getTotalBalance,
            exportData,
            importData,
            addRecurringTransaction,
            updateRecurringTransaction,
            deleteRecurringTransaction,
            toggleRecurringTransaction,
            processRecurringTransactions,
            transferBetweenAccounts,
            addTransferRule,
            updateTransferRule,
            deleteTransferRule,
            toggleTransferRule,
            applyIncomeDistributionRules,
            addIncomeDistributionRule,
            updateIncomeDistributionRule,
            deleteIncomeDistributionRule,
            toggleIncomeDistributionRule,
            saveIncomeDistributionCompletion,
        }),
        [
            isLoading,
            settings,
            accounts,
            categories,
            transactions,
            recurringTransactions,
            transferRules,
            backupMetadata,
            incomeDistributionRules,
            incomeDistributionCompletions,
            updateSettings,
            addAccount,
            updateAccount,
            deleteAccount,
            addTransaction,
            updateTransaction,
            deleteTransaction,
            addCategory,
            deleteCategory,
            getActiveAccounts,
            getCategoriesByType,
            getTransactionsByAccountAndPeriod,
            getPeriodStats,
            getTotalBalance,
            exportData,
            importData,
            addRecurringTransaction,
            updateRecurringTransaction,
            deleteRecurringTransaction,
            toggleRecurringTransaction,
            processRecurringTransactions,
            transferBetweenAccounts,
            addTransferRule,
            updateTransferRule,
            deleteTransferRule,
            toggleTransferRule,
            applyIncomeDistributionRules,
            addIncomeDistributionRule,
            updateIncomeDistributionRule,
            deleteIncomeDistributionRule,
            toggleIncomeDistributionRule,
            saveIncomeDistributionCompletion,
        ],
    );

    return value;
});

export function useCurrentAccount() {
    const { settings, accounts } = useApp();
    const currentAccount = useMemo(() => {
        const activeAccounts = accounts.filter((account) => !account.isArchived);
        if (settings.lastSelectedAccountId) {
            const account = accounts.find((item) => item.id === settings.lastSelectedAccountId);
            if (account && !account.isArchived) {
                return account;
            }
        }
        return activeAccounts[0] || null;
    }, [settings.lastSelectedAccountId, accounts]);

    return currentAccount;
}

export function usePeriodDates(periodType: string) {
    return useMemo(() => {
        const now = new Date();
        let from: Date;
        let to: Date;

        switch (periodType) {
            case "day":
                from = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                to = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);
                break;
            case "week": {
                const day = now.getDay();
                const diff = day === 0 ? 6 : day - 1;
                from = new Date(now);
                from.setDate(now.getDate() - diff);
                from.setHours(0, 0, 0, 0);
                to = new Date(from);
                to.setDate(from.getDate() + 6);
                to.setHours(23, 59, 59, 999);
                break;
            }
            case "month":
                from = new Date(now.getFullYear(), now.getMonth(), 1);
                to = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
                break;
            case "year":
                from = new Date(now.getFullYear(), 0, 1);
                to = new Date(now.getFullYear(), 11, 31, 23, 59, 59, 999);
                break;
            default:
                from = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                to = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);
        }

        return { from, to };
    }, [periodType]);
}
